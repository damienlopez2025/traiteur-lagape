import { supabase } from './supabase';

export const storage = {
    // Providers
    getProviders: async () => {
        const { data, error } = await supabase.from('providers').select('*').order('name');
        if (error) {
            console.error('Error fetching providers:', error);
            return [];
        }
        return data;
    },

    addProvider: async (name) => {
        const { data, error } = await supabase.from('providers').insert([{ name }]).select().single();
        if (error) {
            console.error('Error adding provider:', error);
            return null;
        }
        return data;
    },

    deleteProvider: async (id) => {
        const { error } = await supabase.from('providers').delete().eq('id', id);
        if (error) console.error('Error deleting provider:', error);
    },

    updateProvider: async (id, updates) => {
        const { error } = await supabase.from('providers').update(updates).eq('id', id);
        if (error) console.error('Error updating provider:', error);
    },

    // Products
    getProducts: async () => {
        const { data, error } = await supabase.from('products').select('*').order('name');
        if (error) {
            console.error('Error fetching products:', error);
            return [];
        }
        // Map snake_case database fields back to camelCase for app compatibility if needed, 
        // OR update app to use snake_case. 
        // The DB has price_ttc, cost_ht. The App expects priceTtc, costHt.
        // Let's map them here to minimize App changes.
        return data.map(p => ({
            ...p,
            priceTtc: p.price_ttc,
            costHt: p.cost_ht,
            providerId: p.provider_id
        }));
    },

    addProduct: async (product) => {
        const { data, error } = await supabase.from('products').insert([{
            name: product.name,
            provider_id: product.providerId,
            price_ttc: product.priceTtc,
            cost_ht: product.costHt,
            active: product.active !== false // Default true
        }]).select().single();

        if (error) {
            console.error('Error adding product:', error);
            return null;
        }
        return {
            ...data,
            priceTtc: data.price_ttc,
            costHt: data.cost_ht,
            providerId: data.provider_id
        };
    },

    updateProduct: async (id, updates) => {
        // Map updates to snake_case
        const dbUpdates = {};
        if (updates.active !== undefined) dbUpdates.active = updates.active;
        if (updates.name) dbUpdates.name = updates.name;
        if (updates.priceTtc) dbUpdates.price_ttc = updates.priceTtc;
        if (updates.costHt) dbUpdates.cost_ht = updates.costHt;

        const { error } = await supabase.from('products').update(dbUpdates).eq('id', id);
        if (error) console.error('Error updating product:', error);
    },

    deleteProduct: async (id) => {
        const { error } = await supabase.from('products').delete().eq('id', id);
        if (error) console.error('Error deleting product:', error);
    },

    // Invoices
    getInvoices: async () => {
        const { data, error } = await supabase.from('invoices').select('*').order('date', { ascending: false });
        if (error) {
            console.error('Error fetching invoices:', error);
            return [];
        }

        // Map fields
        return data.map(i => ({
            ...i,
            invoiceNumber: i.invoice_number,
            clientName: i.client_name,
            clientAddress: i.client_address,
            providerId: i.provider_id,
            hasDelivery: i.has_delivery,
            deliveryTtc: i.delivery_ttc,
            deliveryCostHt: i.delivery_cost_ht,
            deliveryAddress: i.delivery_address,
            // lines and totals are JSONB, so they come back as objects automatically
        }));
    },

    saveInvoice: async (invoice) => {
        // invoice object from App has camelCase
        // DB expects snake_case
        // Note: 'id' might be generated by UUIDv4 in App, but Supabase also generates it.
        // If App sends an ID, we use it (upsert).

        const dbInvoice = {
            id: invoice.id,
            invoice_number: invoice.invoiceNumber,
            client_name: invoice.clientName,
            client_address: invoice.clientAddress,
            date: invoice.date,
            provider_id: invoice.providerId,
            lines: invoice.lines,
            totals: invoice.totals,
            has_delivery: invoice.hasDelivery,
            delivery_ttc: invoice.deliveryTtc,
            delivery_cost_ht: invoice.deliveryCostHt,
            contact: invoice.contact,
            delivery_address: invoice.deliveryAddress,
            created_at: invoice.createdAt
        };

        const { data, error } = await supabase.from('invoices').upsert(dbInvoice).select().single();
        if (error) {
            console.error('Error saving invoice:', error);
            throw error;
        }
        return data;
    },

    // Init (No-op now, Supabase manages schema)
    init: async () => {
        // Could check connection
    }
};
